//This file is automatically generated. DO NOT EDIT!
using System;
using RobotRaconteur;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace experimental.createwebcam
{
public class experimental__createwebcamFactory : ServiceFactory
{
    public override string DefString()
{
    const string d=@"#Service to provide sample interface to webcams
service experimental.createwebcam

option version 0.5

struct WebcamImage
    field int32 width
    field int32 height
    field int32 step
    field uint8[] data
end struct

struct WebcamImage_size
    field int32 width
    field int32 height
    field int32 step
end struct

object Webcam
    property string Name
    function WebcamImage CaptureFrame()

    function void StartStreaming()
    function void StopStreaming()
    pipe WebcamImage FrameStream

    function WebcamImage_size CaptureFrameToBuffer()
    memory uint8[] buffer
    memory uint8[*] multidimbuffer

end object

object WebcamHost
    property string{int32} WebcamNames
    objref Webcam{int32} Webcams
end object";
    return d;
    }
    public override string GetServiceName() {return "experimental.createwebcam";}
    public WebcamImage_stub WebcamImage_stubentry;
    public WebcamImage_size_stub WebcamImage_size_stubentry;
    public experimental__createwebcamFactory()
{
    WebcamImage_stubentry=new WebcamImage_stub(this);
    WebcamImage_size_stubentry=new WebcamImage_size_stub(this);
    }
    public override IStructureStub FindStructureStub(string objecttype)
    {
    string objshort=RemovePath(objecttype);
    if (objshort=="WebcamImage")    return WebcamImage_stubentry;
    if (objshort=="WebcamImage_size")    return WebcamImage_size_stubentry;
    throw new DataTypeException("Cannot find appropriate structure stub");
    }
    public override MessageElementStructure PackStructure(Object s) {
    if (s==null) return null;
    string objtype=s.GetType().ToString();
    if (RobotRaconteurNode.SplitQualifiedName(objtype)[0].TrimEnd(new char[] {'_'}) == "experimental.createwebcam") {
    string objshort=RemovePath(objtype);
    switch (objshort) {
    case "WebcamImage":
    return  WebcamImage_stubentry.PackStructure(s);
    case "WebcamImage_size":
    return  WebcamImage_size_stubentry.PackStructure(s);
    default:
    break;
    }
    } else {
    return RobotRaconteurNode.s.PackStructure(s);
    }
    throw new Exception();
    }
    public override T UnpackStructure<T>(MessageElementStructure l) {
    if (l==null) return default(T);
    if (RobotRaconteurNode.SplitQualifiedName(l.Type)[0].TrimEnd(new char[] {'_'}) == "experimental.createwebcam") {
    string objshort=RemovePath(l.Type);
    switch (objshort) {
    case "WebcamImage":
    return  WebcamImage_stubentry.UnpackStructure<T>(l);
    case "WebcamImage_size":
    return  WebcamImage_size_stubentry.UnpackStructure<T>(l);
    default:
    break;
    }
    } else {
    return RobotRaconteurNode.s.UnpackStructure<T>(l);
    }
    throw new DataTypeException("Could not unpack structure");
    }
    public override ServiceStub CreateStub(WrappedServiceStub innerstub) {
    string objecttype=innerstub.RR_objecttype.GetServiceDefinition().Name + "." + innerstub.RR_objecttype.Name;    if (RobotRaconteurNode.SplitQualifiedName(objecttype)[0].TrimEnd(new char[] {'_'}) == "experimental.createwebcam") {
    string objshort=RemovePath(objecttype);
    switch (objshort) {
    case "Webcam":
    return new Webcam_stub(innerstub);
    case "WebcamHost":
    return new WebcamHost_stub(innerstub);
    default:
    break;
    }
    } else {
    string ext_service_type=RobotRaconteurNode.SplitQualifiedName(objecttype)[0].TrimEnd(new char[] {'_'});
    return RobotRaconteurNode.s.GetServiceType(ext_service_type).CreateStub(innerstub);
    }
    throw new ServiceException("Could not create stub");
    }
    public override ServiceSkel CreateSkel(object obj) {
    string objtype=ServiceSkelUtil.UnfixName(ServiceSkelUtil.FindParentInterface(obj.GetType()).ToString());
    if (RobotRaconteurNode.SplitQualifiedName(objtype.ToString())[0].TrimEnd(new char[] {'_'}) == "experimental.createwebcam") {
    string sobjtype=RemovePath(objtype);
    switch(sobjtype) {
    case "Webcam":
    return new Webcam_skel((Webcam)obj);
    case "WebcamHost":
    return new WebcamHost_skel((WebcamHost)obj);
    default:
    break;
    }
    } else {
    string ext_service_type=RobotRaconteurNode.SplitQualifiedName(objtype.ToString())[0].TrimEnd(new char[] {'_'});
    return RobotRaconteurNode.s.GetServiceFactory(ext_service_type).CreateSkel(obj);
    }
    throw new ServiceException("Could not create skel");
    }
    public override RobotRaconteurException DownCastException(RobotRaconteurException rr_exp){
    if (rr_exp==null) return rr_exp;
    string rr_type=rr_exp.Error;
    if (!rr_type.Contains(".")) return rr_exp;
    string[] rr_stype = RobotRaconteurNode.SplitQualifiedName(rr_type);
    if (rr_stype[0] != "experimental.createwebcam") return RobotRaconteurNode.s.DownCastException(rr_exp);
    return rr_exp;
    }
}

public class WebcamImage_stub : IStructureStub {
    public WebcamImage_stub(experimental__createwebcamFactory d) {def=d;}
    private experimental__createwebcamFactory def;
    public MessageElementStructure PackStructure(object s1) {
    using(vectorptr_messageelement m=new vectorptr_messageelement())
    {
    if (s1 ==null) return null;
    WebcamImage s = (WebcamImage)s1;
    MessageElementUtil.AddMessageElementDispose(m,MessageElementUtil.NewMessageElementDispose("width",new int[] {s.width}));
    MessageElementUtil.AddMessageElementDispose(m,MessageElementUtil.NewMessageElementDispose("height",new int[] {s.height}));
    MessageElementUtil.AddMessageElementDispose(m,MessageElementUtil.NewMessageElementDispose("step",new int[] {s.step}));
    MessageElementUtil.AddMessageElementDispose(m,MessageElementUtil.NewMessageElementDispose("data",s.data));
    return new MessageElementStructure("experimental.createwebcam.WebcamImage",m);
    }
    }
    public T UnpackStructure<T>(MessageElementStructure m) {
    if (m == null ) return default(T);
    WebcamImage s=new WebcamImage();
    using(vectorptr_messageelement mm=m.Elements)
    {
    s.width =(MessageElementUtil.CastDataAndDispose<int[]>(MessageElement.FindElement(mm,"width")))[0];
    s.height =(MessageElementUtil.CastDataAndDispose<int[]>(MessageElement.FindElement(mm,"height")))[0];
    s.step =(MessageElementUtil.CastDataAndDispose<int[]>(MessageElement.FindElement(mm,"step")))[0];
    s.data =MessageElementUtil.CastDataAndDispose<byte[]>(MessageElement.FindElement(mm,"data"));
    T st; try {st=(T)((object)s);} catch (InvalidCastException e) {throw new DataTypeMismatchException("Wrong structuretype");}
    return st;
    }
    }
}

public class WebcamImage_size_stub : IStructureStub {
    public WebcamImage_size_stub(experimental__createwebcamFactory d) {def=d;}
    private experimental__createwebcamFactory def;
    public MessageElementStructure PackStructure(object s1) {
    using(vectorptr_messageelement m=new vectorptr_messageelement())
    {
    if (s1 ==null) return null;
    WebcamImage_size s = (WebcamImage_size)s1;
    MessageElementUtil.AddMessageElementDispose(m,MessageElementUtil.NewMessageElementDispose("width",new int[] {s.width}));
    MessageElementUtil.AddMessageElementDispose(m,MessageElementUtil.NewMessageElementDispose("height",new int[] {s.height}));
    MessageElementUtil.AddMessageElementDispose(m,MessageElementUtil.NewMessageElementDispose("step",new int[] {s.step}));
    return new MessageElementStructure("experimental.createwebcam.WebcamImage_size",m);
    }
    }
    public T UnpackStructure<T>(MessageElementStructure m) {
    if (m == null ) return default(T);
    WebcamImage_size s=new WebcamImage_size();
    using(vectorptr_messageelement mm=m.Elements)
    {
    s.width =(MessageElementUtil.CastDataAndDispose<int[]>(MessageElement.FindElement(mm,"width")))[0];
    s.height =(MessageElementUtil.CastDataAndDispose<int[]>(MessageElement.FindElement(mm,"height")))[0];
    s.step =(MessageElementUtil.CastDataAndDispose<int[]>(MessageElement.FindElement(mm,"step")))[0];
    T st; try {st=(T)((object)s);} catch (InvalidCastException e) {throw new DataTypeMismatchException("Wrong structuretype");}
    return st;
    }
    }
}

public interface async_Webcam
{
    void async_get_Name(Action<string,Exception> rr_handler, int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE);
    void async_set_Name(string value, Action<Exception> rr_handler, int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE);
    void async_CaptureFrame(Action<WebcamImage,Exception> rr_handler,int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE);
    void async_StartStreaming(Action<Exception> rr_handler,int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE);
    void async_StopStreaming(Action<Exception> rr_handler,int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE);
    void async_CaptureFrameToBuffer(Action<WebcamImage_size,Exception> rr_handler,int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE);
}
public class Webcam_stub : ServiceStub , Webcam, async_Webcam{
    private Pipe<WebcamImage> rr_FrameStream;
    private ArrayMemory<byte> rr_buffer;
    private MultiDimArrayMemory<byte> rr_multidimbuffer;
    public Webcam_stub(WrappedServiceStub innerstub) : base(innerstub) {
    rr_FrameStream=new Pipe<WebcamImage>(innerstub.GetPipe("FrameStream"));
    rr_buffer=new ArrayMemoryClient<byte>(innerstub.GetArrayMemory("buffer"));
    rr_multidimbuffer=new MultiDimArrayMemoryClient<byte>(innerstub.GetMultiDimArrayMemory("multidimbuffer"));
    }
    public string Name {
    get {
    return MessageElementUtil.CastDataAndDispose<string>(rr_innerstub.PropertyGet("Name"));
    }
    set {
    using(MessageElement m=MessageElementUtil.NewMessageElementDispose("value",value))
    {
    rr_innerstub.PropertySet("Name", m);
    }
    }
    }
    public WebcamImage CaptureFrame() {
    using(vectorptr_messageelement rr_param=new vectorptr_messageelement())
    {
    using(MessageElement rr_me=rr_innerstub.FunctionCall("CaptureFrame",rr_param))
    {
    return RobotRaconteurNode.s.UnpackStructureDispose<WebcamImage>(MessageElementUtil.CastDataAndDispose<MessageElementStructure>(rr_me));
    }
    }
    }
    public void StartStreaming() {
    using(vectorptr_messageelement rr_param=new vectorptr_messageelement())
    {
    using(MessageElement rr_me=rr_innerstub.FunctionCall("StartStreaming",rr_param))
    {
    }
    }
    }
    public void StopStreaming() {
    using(vectorptr_messageelement rr_param=new vectorptr_messageelement())
    {
    using(MessageElement rr_me=rr_innerstub.FunctionCall("StopStreaming",rr_param))
    {
    }
    }
    }
    public WebcamImage_size CaptureFrameToBuffer() {
    using(vectorptr_messageelement rr_param=new vectorptr_messageelement())
    {
    using(MessageElement rr_me=rr_innerstub.FunctionCall("CaptureFrameToBuffer",rr_param))
    {
    return RobotRaconteurNode.s.UnpackStructureDispose<WebcamImage_size>(MessageElementUtil.CastDataAndDispose<MessageElementStructure>(rr_me));
    }
    }
    }
    public override void DispatchEvent(string rr_membername, vectorptr_messageelement rr_m) {
    switch (rr_membername) {
    default:
    break;
    }
    }
    public Pipe<WebcamImage> FrameStream {
    get { return rr_FrameStream;  }
    set { throw new InvalidOperationException();}
    }
    public override MessageElement CallbackCall(string rr_membername, vectorptr_messageelement rr_m) {
    switch (rr_membername) {
    default:
    break;
    }
    throw new MemberNotFoundException("Member not found");
    }
    public ArrayMemory<byte> buffer { 
    get { return rr_buffer; }
    set { throw new InvalidOperationException();}
    }
    public MultiDimArrayMemory<byte> multidimbuffer {
    get { return rr_multidimbuffer; }
    set { throw new InvalidOperationException();}
    }
    public virtual void async_get_Name(Action<string,Exception> rr_handler, int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    rr_async_PropertyGet("Name",rrend_async_get_Name,rr_handler,rr_timeout);
    }
    protected virtual void rrend_async_get_Name(MessageElement value ,Exception err,object param)
    {
    Action<string,Exception> rr_handler=(Action<string,Exception>)param;
    if (err!=null)
    {
    rr_handler("",err);
    return;
    }
    string rr_ret;
    try {
    rr_ret=MessageElementUtil.CastDataAndDispose<string>(value);
    } catch (Exception err2) {
    rr_handler("",err2);
    return;
    }
    rr_handler(rr_ret,null);
    }
    public virtual void async_set_Name(string value, Action<Exception> rr_handler, int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    using(MessageElement mm=MessageElementUtil.NewMessageElementDispose("value",value))
    {
    rr_async_PropertySet("Name",mm,rrend_async_set_Name,rr_handler,rr_timeout);
    }
    }
    protected virtual void rrend_async_set_Name(MessageElement m ,Exception err,object param)
    {
    Action<Exception> rr_handler=(Action<Exception>)param;
    if (err!=null)
    {
    rr_handler(err);
    return;
    }
    rr_handler(null);
    }
    public virtual void async_CaptureFrame(Action<WebcamImage,Exception> rr_handler,int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    using(vectorptr_messageelement rr_param=new vectorptr_messageelement())
    {
    rr_async_FunctionCall("CaptureFrame",rr_param,rrend_async_CaptureFrame,rr_handler,rr_timeout);
    }
    }
    protected virtual void rrend_async_CaptureFrame(MessageElement ret ,Exception err,object param)
    {
    Action<WebcamImage,Exception> rr_handler=(Action<WebcamImage,Exception>)param;
    if (err!=null)
    {
    rr_handler(null,err);
    return;
    }
    WebcamImage rr_ret;
    try {
    rr_ret=RobotRaconteurNode.s.UnpackStructureDispose<WebcamImage>(MessageElementUtil.CastDataAndDispose<MessageElementStructure>(ret));
    } catch (Exception err2) {
    rr_handler(null,err2);
    return;
    }
    rr_handler(rr_ret,null);
    }
    public virtual void async_StartStreaming(Action<Exception> rr_handler,int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    using(vectorptr_messageelement rr_param=new vectorptr_messageelement())
    {
    rr_async_FunctionCall("StartStreaming",rr_param,rrend_async_StartStreaming,rr_handler,rr_timeout);
    }
    }
    protected virtual void rrend_async_StartStreaming(MessageElement ret ,Exception err,object param)
    {
    Action<Exception> rr_handler=(Action<Exception>)param;
    if (err!=null)
    {
    rr_handler(err);
    return;
    }
    rr_handler(null);
    }
    public virtual void async_StopStreaming(Action<Exception> rr_handler,int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    using(vectorptr_messageelement rr_param=new vectorptr_messageelement())
    {
    rr_async_FunctionCall("StopStreaming",rr_param,rrend_async_StopStreaming,rr_handler,rr_timeout);
    }
    }
    protected virtual void rrend_async_StopStreaming(MessageElement ret ,Exception err,object param)
    {
    Action<Exception> rr_handler=(Action<Exception>)param;
    if (err!=null)
    {
    rr_handler(err);
    return;
    }
    rr_handler(null);
    }
    public virtual void async_CaptureFrameToBuffer(Action<WebcamImage_size,Exception> rr_handler,int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    using(vectorptr_messageelement rr_param=new vectorptr_messageelement())
    {
    rr_async_FunctionCall("CaptureFrameToBuffer",rr_param,rrend_async_CaptureFrameToBuffer,rr_handler,rr_timeout);
    }
    }
    protected virtual void rrend_async_CaptureFrameToBuffer(MessageElement ret ,Exception err,object param)
    {
    Action<WebcamImage_size,Exception> rr_handler=(Action<WebcamImage_size,Exception>)param;
    if (err!=null)
    {
    rr_handler(null,err);
    return;
    }
    WebcamImage_size rr_ret;
    try {
    rr_ret=RobotRaconteurNode.s.UnpackStructureDispose<WebcamImage_size>(MessageElementUtil.CastDataAndDispose<MessageElementStructure>(ret));
    } catch (Exception err2) {
    rr_handler(null,err2);
    return;
    }
    rr_handler(rr_ret,null);
    }
}
public interface async_WebcamHost
{
    void async_get_WebcamNames(Action<Dictionary<int,string>,Exception> rr_handler, int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE);
    void async_set_WebcamNames(Dictionary<int,string> value, Action<Exception> rr_handler, int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE);
    void async_get_Webcams(int ind, Action<Webcam,Exception> handler, int timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE);
}
public class WebcamHost_stub : ServiceStub , WebcamHost, async_WebcamHost{
    public WebcamHost_stub(WrappedServiceStub innerstub) : base(innerstub) {
    }
    public Dictionary<int,string> WebcamNames {
    get {
    return (Dictionary<int,string>)RobotRaconteurNode.s.UnpackMapTypeDispose<int,string>(rr_innerstub.PropertyGet("WebcamNames").Data);
    }
    set {
    using(MessageElement m=MessageElementUtil.NewMessageElementDispose("value",RobotRaconteurNode.s.PackMapType<int,string>(value)))
    {
    rr_innerstub.PropertySet("WebcamNames", m);
    }
    }
    }
    public override void DispatchEvent(string rr_membername, vectorptr_messageelement rr_m) {
    switch (rr_membername) {
    default:
    break;
    }
    }
    public Webcam get_Webcams(int ind) {
    return (Webcam)FindObjRefTyped("Webcams",ind.ToString(),"experimental.createwebcam.Webcam");
    }
    public override MessageElement CallbackCall(string rr_membername, vectorptr_messageelement rr_m) {
    switch (rr_membername) {
    default:
    break;
    }
    throw new MemberNotFoundException("Member not found");
    }
    public virtual void async_get_WebcamNames(Action<Dictionary<int,string>,Exception> rr_handler, int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    rr_async_PropertyGet("WebcamNames",rrend_async_get_WebcamNames,rr_handler,rr_timeout);
    }
    protected virtual void rrend_async_get_WebcamNames(MessageElement value ,Exception err,object param)
    {
    Action<Dictionary<int,string>,Exception> rr_handler=(Action<Dictionary<int,string>,Exception>)param;
    if (err!=null)
    {
    rr_handler(null,err);
    return;
    }
    Dictionary<int,string> rr_ret;
    try {
    rr_ret=(Dictionary<int,string>)RobotRaconteurNode.s.UnpackMapTypeDispose<int,string>(value.Data);
    } catch (Exception err2) {
    rr_handler(null,err2);
    return;
    }
    rr_handler(rr_ret,null);
    }
    public virtual void async_set_WebcamNames(Dictionary<int,string> value, Action<Exception> rr_handler, int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    using(MessageElement mm=MessageElementUtil.NewMessageElementDispose("value",RobotRaconteurNode.s.PackMapType<int,string>(value)))
    {
    rr_async_PropertySet("WebcamNames",mm,rrend_async_set_WebcamNames,rr_handler,rr_timeout);
    }
    }
    protected virtual void rrend_async_set_WebcamNames(MessageElement m ,Exception err,object param)
    {
    Action<Exception> rr_handler=(Action<Exception>)param;
    if (err!=null)
    {
    rr_handler(err);
    return;
    }
    rr_handler(null);
    }
    public void async_get_Webcams(int ind, Action<Webcam,Exception> handler, int timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    AsyncFindObjRefTyped("Webcams",ind.ToString(),"experimental.createwebcam.Webcam",handler,timeout);
    }
}
public class Webcam_skel : ServiceSkel {
    protected Webcam obj;
    public Webcam_skel(object o) : base(o) { obj=(Webcam)o; }
    public override void ReleaseCastObject() { 
    obj=null;
    base.ReleaseCastObject();
    }
    public override MessageElement CallGetProperty(string membername) {
    switch (membername) {
    case "Name":
    {
    string ret=obj.Name;
    return MessageElementUtil.NewMessageElementDispose("return",ret);
    }
    default:
    break;
    }
    throw new MemberNotFoundException("Member not found");
    }
    public override void CallSetProperty(string membername, MessageElement m) {
    switch (membername) {
    case "Name":
    {
    obj.Name=MessageElementUtil.CastDataAndDispose<string>(m);
    return;
    }
    default:
    break;
    }
    throw new MemberNotFoundException("Member not found");
    }
    public override MessageElement CallFunction(string rr_membername, vectorptr_messageelement rr_m) {
    switch (rr_membername) {
    case "CaptureFrame":
    {
    WebcamImage rr_ret=this.obj.CaptureFrame();
    return MessageElementUtil.NewMessageElementDispose("return",RobotRaconteurNode.s.PackStructure(rr_ret));
    }
    case "StartStreaming":
    {
    this.obj.StartStreaming();
    return new MessageElement("return",(int)0);
    }
    case "StopStreaming":
    {
    this.obj.StopStreaming();
    return new MessageElement("return",(int)0);
    }
    case "CaptureFrameToBuffer":
    {
    WebcamImage_size rr_ret=this.obj.CaptureFrameToBuffer();
    return MessageElementUtil.NewMessageElementDispose("return",RobotRaconteurNode.s.PackStructure(rr_ret));
    }
    default:
    break;
    }
    throw new MemberNotFoundException("Member not found");
    }
    public override object GetSubObj(string name, string ind) {
    switch (name) {
    default:
    break;
    }
    throw new MemberNotFoundException("");
    }
    public override void RegisterEvents(object rrobj1) {
    obj=(Webcam)rrobj1;
    }
    public override void UnregisterEvents(object rrobj1) {
    obj=(Webcam)rrobj1;
    }
    public override object GetCallbackFunction(uint rr_endpoint, string rr_membername) {
    switch (rr_membername) {
    default:
    break;
    }
    throw new MemberNotFoundException("Member not found");
    }
    public override void InitPipeServers(object rrobj1) {
    obj=(Webcam)rrobj1;
    obj.FrameStream=new Pipe<WebcamImage>(innerskel.GetPipe("FrameStream"));
    }
    public override void InitCallbackServers(object rrobj1) {
    obj=(Webcam)rrobj1;
    }
    public override void InitWireServers(object rrobj1) {
    obj=(Webcam)rrobj1;
    }
    public override WrappedArrayMemoryDirector GetArrayMemory(string name) {
    switch (name) {
    case "buffer": {
    WrappedArrayMemoryDirectorNET<byte> dir=new  WrappedArrayMemoryDirectorNET<byte>(obj.buffer);
    return dir;
    }
    default:
    break;
    }
    throw new MemberNotFoundException("Member Not Found");
    }
    public override WrappedMultiDimArrayMemoryDirector GetMultiDimArrayMemory(string name) {
    switch (name) {
    case "multidimbuffer": {
    WrappedMultiDimArrayMemoryDirectorNET<byte> dir=new  WrappedMultiDimArrayMemoryDirectorNET<byte>(obj.multidimbuffer);
    return dir;
    }
    default:
    break;
    }
    throw new MemberNotFoundException("Member Not Found");
    }
    public override string RRType { get { return "experimental.createwebcam.Webcam"; } }
}
public class WebcamHost_skel : ServiceSkel {
    protected WebcamHost obj;
    public WebcamHost_skel(object o) : base(o) { obj=(WebcamHost)o; }
    public override void ReleaseCastObject() { 
    obj=null;
    base.ReleaseCastObject();
    }
    public override MessageElement CallGetProperty(string membername) {
    switch (membername) {
    case "WebcamNames":
    {
    Dictionary<int,string> ret=obj.WebcamNames;
    return MessageElementUtil.NewMessageElementDispose("return",RobotRaconteurNode.s.PackMapType<int,string>(ret));
    }
    default:
    break;
    }
    throw new MemberNotFoundException("Member not found");
    }
    public override void CallSetProperty(string membername, MessageElement m) {
    switch (membername) {
    case "WebcamNames":
    {
    obj.WebcamNames=(Dictionary<int,string>)RobotRaconteurNode.s.UnpackMapTypeDispose<int,string>(m.Data);
    return;
    }
    default:
    break;
    }
    throw new MemberNotFoundException("Member not found");
    }
    public override MessageElement CallFunction(string rr_membername, vectorptr_messageelement rr_m) {
    switch (rr_membername) {
    default:
    break;
    }
    throw new MemberNotFoundException("Member not found");
    }
    public override object GetSubObj(string name, string ind) {
    switch (name) {
    case "Webcams": {
    return obj.get_Webcams(Int32.Parse(ind));
    }
    default:
    break;
    }
    throw new MemberNotFoundException("");
    }
    public override void RegisterEvents(object rrobj1) {
    obj=(WebcamHost)rrobj1;
    }
    public override void UnregisterEvents(object rrobj1) {
    obj=(WebcamHost)rrobj1;
    }
    public override object GetCallbackFunction(uint rr_endpoint, string rr_membername) {
    switch (rr_membername) {
    default:
    break;
    }
    throw new MemberNotFoundException("Member not found");
    }
    public override void InitPipeServers(object rrobj1) {
    obj=(WebcamHost)rrobj1;
    }
    public override void InitCallbackServers(object rrobj1) {
    obj=(WebcamHost)rrobj1;
    }
    public override void InitWireServers(object rrobj1) {
    obj=(WebcamHost)rrobj1;
    }
    public override WrappedArrayMemoryDirector GetArrayMemory(string name) {
    switch (name) {
    default:
    break;
    }
    throw new MemberNotFoundException("Member Not Found");
    }
    public override WrappedMultiDimArrayMemoryDirector GetMultiDimArrayMemory(string name) {
    switch (name) {
    default:
    break;
    }
    throw new MemberNotFoundException("Member Not Found");
    }
    public override string RRType { get { return "experimental.createwebcam.WebcamHost"; } }
}
public static class RRExtensions{
    public static Task<string> async_get_Name(this async_Webcam rr_obj, int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    RobotRaconteurTaskCompletion<string> t=new RobotRaconteurTaskCompletion<string>();
    rr_obj.async_get_Name(t.handler,rr_timeout);
    return t.Task;
    }
    public static Task async_set_Name(this async_Webcam rr_obj, string value, int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    RobotRaconteurVoidTaskCompletion t=new RobotRaconteurVoidTaskCompletion();
    rr_obj.async_set_Name(value,t.handler,rr_timeout);
    return t.Task;
    }
    public static Task<WebcamImage> async_CaptureFrame(this async_Webcam rr_obj,int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    RobotRaconteurTaskCompletion<WebcamImage> rr_t=new RobotRaconteurTaskCompletion<WebcamImage>();
    rr_obj.async_CaptureFrame(rr_t.handler,rr_timeout);
    return rr_t.Task;
    }
    public static Task async_StartStreaming(this async_Webcam rr_obj,int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    RobotRaconteurVoidTaskCompletion rr_t=new RobotRaconteurVoidTaskCompletion();
    rr_obj.async_StartStreaming(rr_t.handler,rr_timeout);
    return rr_t.Task;
    }
    public static Task async_StopStreaming(this async_Webcam rr_obj,int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    RobotRaconteurVoidTaskCompletion rr_t=new RobotRaconteurVoidTaskCompletion();
    rr_obj.async_StopStreaming(rr_t.handler,rr_timeout);
    return rr_t.Task;
    }
    public static Task<WebcamImage_size> async_CaptureFrameToBuffer(this async_Webcam rr_obj,int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    RobotRaconteurTaskCompletion<WebcamImage_size> rr_t=new RobotRaconteurTaskCompletion<WebcamImage_size>();
    rr_obj.async_CaptureFrameToBuffer(rr_t.handler,rr_timeout);
    return rr_t.Task;
    }
    public static Task<Dictionary<int,string>> async_get_WebcamNames(this async_WebcamHost rr_obj, int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    RobotRaconteurTaskCompletion<Dictionary<int,string>> t=new RobotRaconteurTaskCompletion<Dictionary<int,string>>();
    rr_obj.async_get_WebcamNames(t.handler,rr_timeout);
    return t.Task;
    }
    public static Task async_set_WebcamNames(this async_WebcamHost rr_obj, Dictionary<int,string> value, int rr_timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    RobotRaconteurVoidTaskCompletion t=new RobotRaconteurVoidTaskCompletion();
    rr_obj.async_set_WebcamNames(value,t.handler,rr_timeout);
    return t.Task;
    }
    public static Task<Webcam> async_get_Webcams(this async_WebcamHost rr_obj, int ind, int timeout=RobotRaconteurNode.RR_TIMEOUT_INFINITE)
    {
    RobotRaconteurTaskCompletion<Webcam> t=new RobotRaconteurTaskCompletion<Webcam>();
    rr_obj.async_get_Webcams(ind,t.handler,timeout);
    return t.Task;
    }
}
}
